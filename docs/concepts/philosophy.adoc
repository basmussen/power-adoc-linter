= Konzepte und Philosophie
:toc:
:toc-title: Inhalt
:toclevels: 3
:icons: font
:source-highlighter: highlight.js

[abstract]
Verstehen Sie die Grundkonzepte und Designphilosophie hinter dem Power AsciiDoc Linter. Erfahren Sie, warum bestimmte Entscheidungen getroffen wurden und wie Sie den Linter optimal fÃ¼r Ihre BedÃ¼rfnisse einsetzen.

== ğŸ¯ Vision

[quote, Power AsciiDoc Linter Team]
____
Technische Dokumentation sollte genauso rigoros validiert werden wie Code. Konsistenz, VollstÃ¤ndigkeit und QualitÃ¤t sind keine optionalen Features â€“ sie sind essentiell fÃ¼r wartbare Dokumentation.
____

Der Power AsciiDoc Linter wurde entwickelt, um:

* **QualitÃ¤t zu automatisieren** - Manuelle Reviews sind wichtig, aber fehleranfÃ¤llig
* **Standards durchzusetzen** - Einheitliche Dokumentation im gesamten Projekt
* **FrÃ¼h zu validieren** - Probleme in der CI/CD Pipeline erkennen, nicht erst beim Release
* **Flexibel zu bleiben** - Anpassbar an verschiedene Dokumentationsstandards

== ğŸ—ï¸ Kernkonzepte

=== 1. Hierarchische Validierung

Die Dokumentstruktur wird als Baum betrachtet:

[.text-center]
....
                    Document
                   /        \
              Metadata      Sections
                            /   |   \
                      Sectionâ‚  ...  Sectionâ‚™
                         |
                      Blocks
                     /  |  \
              Paragraph Table Listing
....

**Warum hierarchisch?**

* **NatÃ¼rliche Abbildung** - AsciiDoc ist selbst hierarchisch
* **Flexible Regeln** - Verschiedene Regeln fÃ¼r verschiedene Kontexte
* **Vererbung** - Einstellungen kÃ¶nnen vererbt werden
* **Skalierbarkeit** - GroÃŸe Dokumente bleiben handhabbar

=== 2. Konfiguration als Code

YAML-basierte Konfiguration behandeln wir wie Code:

[source,yaml]
----
document:                    # Root-Objekt
  metadata:                  # Klar strukturiert
    attributes:              # Arrays fÃ¼r Listen
      - name: title          # Objekte fÃ¼r KomplexitÃ¤t
        required: true       # Explizite Werte
        severity: error      # Keine Magie
----

**Prinzipien:**

* **Versionierbar** - Konfiguration im Git Repository
* **Reviewbar** - Ã„nderungen in Pull Requests
* **Testbar** - Verschiedene Configs fÃ¼r verschiedene Docs
* **Dokumentierbar** - YAML ist selbstdokumentierend

=== 3. Severity-System

Drei Stufen fÃ¼r unterschiedliche BedÃ¼rfnisse:

[plantuml, severity-flow, svg]
----
@startuml
!theme plain
skinparam defaultFontSize 14

rectangle "ERROR ğŸ”´" #FFCCCC {
  note right : Build bricht ab\nMUSS behoben werden
}

rectangle "WARN ğŸŸ¡" #FFFFCC {
  note right : Wichtiger Hinweis\nSOLLTE behoben werden
}

rectangle "INFO ğŸ”µ" #CCCCFF {
  note right : Verbesserungsvorschlag\nKANN behoben werden
}

ERROR --> WARN : Weniger kritisch
WARN --> INFO : Noch weniger kritisch
@enduml
----

**Anwendung:**

* **ERROR** - Verletzt harte Anforderungen (z.B. fehlende Pflichtfelder)
* **WARN** - Verletzt Konventionen (z.B. Namenskonventionen)
* **INFO** - OptimierungsvorschlÃ¤ge (z.B. fehlende optionale Metadaten)

=== 4. Pattern-basierte FlexibilitÃ¤t

Statt starrer Listen nutzen wir Patterns:

[cols="40,60", options="header"]
|===
| Starr | Flexibel

a|
[source,yaml]
----
sections:
  - name: "Einleitung"
  - name: "Hauptteil"
  - name: "Fazit"
----

a|
[source,yaml]
----
sections:
  - pattern: "^\\d+\\.\\s+.*"
  # Erlaubt: 1. Einleitung,
  #          2. Hauptteil,
  #          3. Fazit, etc.
----
|===

**Vorteile:**

* **EvolutionsfÃ¤hig** - Neue Sections ohne Config-Ã„nderung
* **Kontext-sensitiv** - Verschiedene Patterns fÃ¼r verschiedene Dokumente
* **Wartbar** - Ein Pattern statt 20 Namen

== ğŸ“ Design-Entscheidungen

=== Warum YAML?

Wir haben uns fÃ¼r YAML entschieden, weil:

1. **Menschenlesbar** - Entwickler kÃ¶nnen Config ohne Doku verstehen
2. **Hierarchisch** - Passt perfekt zur Dokumentstruktur
3. **Etabliert** - Bekannt aus CI/CD, Kubernetes, etc.
4. **Tooling** - Gute Editor-UnterstÃ¼tzung

Alternative Ãœberlegungen:
- âŒ JSON - Zu verbose, keine Kommentare
- âŒ XML - Zu komplex fÃ¼r einfache Configs
- âŒ TOML - Weniger verbreitet, schlechtere Hierarchie-Darstellung

=== Warum keine GUI?

Der Linter ist CLI-first, weil:

1. **Automatisierung** - CI/CD Integration ist primÃ¤res Ziel
2. **Versionskontrolle** - Text-basierte Configs sind Git-freundlich
3. **Skalierung** - Batch-Verarbeitung von hunderten Dateien
4. **Unix-Philosophie** - Ein Tool, eine Aufgabe, gut gemacht

=== Warum Java?

Java wurde gewÃ¤hlt fÃ¼r:

1. **AsciidoctorJ** - Beste AsciiDoc-Implementation
2. **Performance** - JVM-Optimierungen fÃ¼r groÃŸe Dokumente
3. **PortabilitÃ¤t** - LÃ¤uft Ã¼berall wo Java lÃ¤uft
4. **Ã–kosystem** - Reiche Auswahl an Libraries

== ğŸ”„ Validierungs-Workflow

Der Linter folgt diesem Ablauf:

[plantuml, validation-flow, svg]
----
@startuml
start
:Konfiguration laden;
:Schema validieren;
:AsciiDoc parsen;
fork
  :Metadata validieren;
fork again
  :Sections validieren;
fork again
  :Blocks validieren;
end fork
:Ergebnisse sammeln;
:Report generieren;
stop
@enduml
----

**Wichtige Aspekte:**

* **Fail-Fast** - Bei kritischen Fehlern frÃ¼h abbrechen
* **Parallel** - UnabhÃ¤ngige Validierungen parallel
* **VollstÃ¤ndig** - Alle Fehler sammeln, nicht nur ersten

== ğŸ¨ Erweiterbarkeit

=== Plugin-Architektur

Obwohl noch nicht vollstÃ¤ndig implementiert, ist die Architektur darauf vorbereitet:

[source,java]
----
interface BlockValidator {
    List<ValidationResult> validate(Block block, Config config);
}

// Neue Validatoren einfach hinzufÃ¼gen
class CustomBlockValidator implements BlockValidator {
    // Implementation
}
----

=== Custom Rules

ZukÃ¼nftige Erweiterungen kÃ¶nnten erlauben:

[source,yaml]
----
document:
  customRules:
    - class: "com.mycompany.SpecialValidator"
      config:
        specialParam: "value"
----

== ğŸŒŸ Best Practices

=== 1. Inkrementelle Adoption

[.lead]
Starten Sie klein und wachsen Sie mit Ihren Anforderungen.

**Phase 1: Basis**
[source,yaml]
----
document:
  metadata:
    attributes:
      - name: title
        required: true
        severity: error
----

**Phase 2: Struktur**
[source,yaml]
----
# ... Metadata von Phase 1 ...
  sections:
    - name: "Einleitung"
      required: true
      severity: warn
----

**Phase 3: Details**
[source,yaml]
----
# ... Phase 1 & 2 ...
      blocks:
        - paragraph:
            minLines: 5
            severity: info
----

=== 2. Team-Standards

Entwickeln Sie Standards im Team:

1. **Workshop** - Gemeinsam Anforderungen definieren
2. **Pilot** - Mit einem Projekt starten
3. **Feedback** - Regeln basierend auf Erfahrung anpassen
4. **Rollout** - Auf alle Projekte ausweiten

=== 3. Living Documentation

Behandeln Sie Ihre Linter-Konfiguration als lebendiges Dokument:

* **Kommentare** - ErklÃ¤ren Sie komplexe Patterns
* **Versionierung** - Nutzen Sie Git-Tags fÃ¼r Config-Versionen
* **Changelog** - Dokumentieren Sie Ã„nderungen
* **Reviews** - Config-Ã„nderungen im Team besprechen

== ğŸš€ Zukunftsvision

=== Kurzfristig (v1.x)

* âœ… Solide Basis-Validierung
* âœ… CI/CD Integration
* ğŸš§ Watch-Mode fÃ¼r Entwicklung
* ğŸš§ Bessere Fehler-Kontexte

=== Mittelfristig (v2.x)

* ğŸ“‹ Plugin-System
* ğŸ“‹ IDE-Integration
* ğŸ“‹ Auto-Fix fÃ¼r einfache Probleme
* ğŸ“‹ Performance-Optimierungen

=== Langfristig (v3.x)

* ğŸ”® KI-gestÃ¼tzte VorschlÃ¤ge
* ğŸ”® Cross-Dokument-Validierung
* ğŸ”® Stil-Analyse
* ğŸ”® Metriken und Trends

== ğŸ’­ Philosophische GrundsÃ¤tze

[quote, Unix-Philosophie]
____
Do one thing and do it well.
____

Der Power AsciiDoc Linter:

1. **Validiert** - Das ist seine einzige Aufgabe
2. **Integriert** - Passt in bestehende Workflows
3. **Respektiert** - Zwingt keinen Stil auf
4. **Hilft** - Gibt konstruktives Feedback

[quote, Zen of Python (angepasst)]
____
Explizit ist besser als implizit.
Einfach ist besser als komplex.
Komplex ist besser als kompliziert.
Flach ist besser als verschachtelt.
Lesbarkeit zÃ¤hlt.
SpezialfÃ¤lle sind nicht speziell genug, um die Regeln zu brechen.
PraktikabilitÃ¤t schlÃ¤gt Purismus.
____

== ğŸ¤ Community-Philosophie

=== Open Source First

* **Transparenz** - Entwicklung Ã¶ffentlich auf GitHub
* **Kollaboration** - Pull Requests willkommen
* **Dokumentation** - Umfassend und aktuell
* **Support** - Community-getrieben

=== InklusivitÃ¤t

* **Mehrsprachig** - Dokumentation in mehreren Sprachen
* **AnfÃ¤ngerfreundlich** - Klare Beispiele und Guides
* **Barrierefreiheit** - Ausgaben screen-reader-freundlich
* **Diverses Feedback** - Alle Perspektiven willkommen

== ğŸ“ Lernen aus der Praxis

=== Was funktioniert

âœ… **Klare Fehlermeldungen** - "actual X, expected Y"
âœ… **Flexible Patterns** - Nicht zu restriktiv
âœ… **Hierarchische Config** - NatÃ¼rliche Struktur
âœ… **Exit-Codes** - CI/CD-freundlich

=== Was wir gelernt haben

ğŸ“š **Balance** - Zwischen Striktheit und FlexibilitÃ¤t
ğŸ“š **Kontext** - Fehler mit umgebendem Code zeigen
ğŸ“š **Performance** - Caching fÃ¼r groÃŸe Projekte wichtig
ğŸ“š **RÃ¼ckwÃ¤rtskompatibilitÃ¤t** - Config-Migrationen planen

== ğŸ”— WeiterfÃ¼hrende Konzepte

* link:rule-hierarchy-diagram.adoc[Regel-Hierarchie im Detail]
* link:severity-inheritance-diagram.adoc[Severity-Vererbung verstehen]
* link:../user-guide/configuration.adoc[Praktische Konfiguration]
* link:../architecture/design-patterns.adoc[Technische Design-Patterns]